import os
import threading
import time

import pygame

from util import make_path


#
# {
#    C: { chord, h1, h2, h3, ... }
#    Bb: { chord, h1, h2, h3, ... }
# }

class AudioManager:
    def __init__(self, window, slow_down_chord=1.0, slow_down_harp=1.0):
        pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=512)

        self.window = window
        self.dict = {}
        self.current_chord_name = None

        # single channel for chord playback
        self.chord_channel = pygame.mixer.Channel(0)

        # multiple channels for harp playback
        self.harp_channels = [pygame.mixer.Channel(i) for i in range(1, 8)]
        self.harp_channel_index = 0

        # control
        self.chord_playing = False
        self.lock = threading.Lock()

        # slowdown
        self.slow_down_chord = slow_down_chord
        self.slow_down_harp = slow_down_harp

        self._read_all_from_sounds_folder()

    def _read_all_from_sounds_folder(self):
        """Load all audio files from the sounds folder"""
        sounds_folder = make_path("sounds")
        chords = [f for f in os.listdir(sounds_folder)
                  if os.path.isdir(os.path.join(sounds_folder, f))]

        for chord in chords:
            chord_path = os.path.join(sounds_folder, chord)
            files = [f for f in os.listdir(chord_path) if f.endswith('.ogg')]

            self.dict[chord] = {}

            for file in files:
                file_path = os.path.join(chord_path, file)

                try:
                    sound = pygame.mixer.Sound(file_path)

                    if file.endswith('chord.ogg'):
                        self.dict[chord]['chord'] = sound
                    else:
                        harp_note = file.replace(chord, '', 1).replace('.ogg', '')
                        self.dict[chord][harp_note] = sound

                except Exception as e:
                    print(f"Error loading {file_path}: {e}")

        print(f"Loaded {len(self.dict)} chords")

    def play_chord(self, token):
        """Play a chord on loop"""
        if not self.window.is_playing:
            return

        with self.lock:
            if self.chord_playing:
                self.chord_channel.stop()

            if token not in self.dict or 'chord' not in self.dict[token]:
                print(f"Chord {token} not found.")
                return

            chord_sound = self.dict[token]['chord']
            self.current_chord_name = token

            self.chord_channel.play(chord_sound, loops=-1)
            self.chord_playing = True
            self.current_chord_name = token

    def play_harp(self, token):
        """Play a harp note once using one of the harp channels"""
        if not self.window.is_playing:
            return

        if self.current_chord_name is None:
            print("No chord is currently playing. Cannot play harp note.")
            return

        try:
            harp_key = str(int(token) - 1)  # although H1 is the first harp, the files start on 0
        except ValueError:
            print(f"Invalid harp token: {token}")
            return

        harp_sound = self.dict[self.current_chord_name].get(harp_key)
        if harp_sound is None:
            print(f"Harp note {token} not found for chord {self.current_chord_name}")
            return

        # get the next available harp channel so we dont stop the currently playing harp
        channel = self.harp_channels[self.harp_channel_index]
        self.harp_channel_index = (self.harp_channel_index + 1) % len(self.harp_channels)

        channel.play(harp_sound, loops=0)

    def interpret_sequence(self, text):
        """Interprets a sequence of tokens generated by the model"""
        tokens = text.split()
        for token in tokens:
            if not self.window.is_playing:
                break

            if '_' not in token:
                continue

            parts = token.split('_')
            if len(parts) != 2:
                continue

            name, duration_str = parts
            try:
                duration_ms = int(duration_str)
            except ValueError:
                print(f"Invalid duration in token: {token}")
                continue

            if name in self.dict:
                self.play_chord(name)
                time.sleep(duration_ms * self.slow_down_chord / 1000.0)
            elif name.startswith('H'):
                harp_note = name[1:]
                self.play_harp(harp_note)
                time.sleep(duration_ms * self.slow_down_harp / 1000.0)
            else:
                print(f"Unknown token: {token}")
                raise ValueError(f"Unknown chord name: {name}")

    def stop_all(self):
        """Stop all audio playback"""
        with self.lock:
            self.chord_channel.stop()
            for channel in self.harp_channels:
                channel.stop()
            self.chord_playing = False
            self.current_chord_name = None
            print("Stopped all audio")

    def __del__(self):
        """Clean up pygame mixer resources"""
        try:
            self.stop_all()
            pygame.mixer.quit()
        except:
            pass
